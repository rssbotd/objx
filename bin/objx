#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=R0903,C0413


"locate"


import os
import sys
import time


sys.path.insert(0, os.getcwd())


from objx.default import Default
from objx.config  import Config
from objx.object  import Object, fmt, keys
from objx.persist import Persist, find, long, skel, sync, types
from objx.utility import fntime, laps


Cfg         = Config()
Cfg.name    = Config.__module__.rsplit(".", maxsplit=1)[-2]
Cfg.wdr     = os.path.expanduser(f"~/.{Cfg.name}")
Cfg.pidfile = os.path.join(Cfg.wdr, f"{Cfg.name}.pid")


Persist.workdir = Cfg.wdr


class Result(Default):

    "Result"

    def __init__(self):
        Default.__init__(self)
        self.result  = []
        self.txt     = ""

    def reply(self, txt):
        "add text to the result"
        self.result.append(txt)


class Commands:

    "Commands"

    cmds = Object()

    @staticmethod
    def add(func):
        "add command."
        setattr(Commands.cmds, func.__name__, func)


def command(evt):
    "check for and run a command."
    parse(evt)
    func = getattr(Commands.cmds, evt.cmd, None)
    if func:
        func(evt)


def parse(obj, txt=None):
    "parse a string for a command."
    args = []
    _nr = -1
    obj.otxt = txt or obj.otxt or obj.txt
    for spli in obj.otxt.split():
        if spli.startswith("-"):
            try:
                obj.index = int(spli[1:])
            except ValueError:
                obj.opts += spli[1:]
            continue
        if "==" in spli:
            key, value = spli.split("==", maxsplit=1)
            if not obj.gets:
                obj.gets = Default()
            if key in obj.gets:
                val = getattr(obj.gets, key)
                value = val + "," + value
            setattr(obj.gets, key, value)
            continue
        if "=" in spli:
            key, value = spli.split("=", maxsplit=1)
            if key == "mod":
                obj.hasmods = True
                if obj.mod:
                    obj.mod += f",{value}"
                else:
                    obj.mod = value
                continue
            if not obj.gets:
                obj.gets = Default()
            setattr(obj.sets, key, value)
            continue
        _nr += 1
        if _nr == 0:
            obj.cmd = spli
            continue
        args.append(spli)
    if args:
        obj.args = args
        obj.txt  = obj.cmd or ""
        obj.rest = " ".join(obj.args)
        obj.txt  = obj.cmd + " " + obj.rest
    else:
        obj.txt = obj.cmd or ""



def cmd(event):
    "list commands."
    event.reply(",".join(sorted(keys(Commands.cmds))))


def fnd(event):
    "locate objects."
    skel()
    if not event.rest:
        res = sorted([x.split('.')[-1].lower() for x in types()])
        if res:
            event.reply(",".join(res))
        return
    otype = long(event.args[0])
    nmr = 0
    for fnm, obj in find(otype, event.gets):
        event.reply(f"{nmr} {fmt(obj)} {laps(time.time()-fntime(fnm))}")
        nmr += 1
    if not nmr:
        event.reply("no result")


class Log(Object):

    "Log"

    def __init__(self):
        super().__init__()
        self.txt = ''


def log(event):
    "log text."
    if not event.rest:
        nmr = 0
        for fnm, obj in find('log'):
            lap = laps(time.time() - fntime(fnm))
            event.reply(f'{nmr} {obj.txt} {lap}')
            nmr += 1
        if not nmr:
            event.reply('no log')
        return
    obj = Log()
    obj.txt = event.rest
    sync(obj)
    event.reply('ok')


if __name__ == "__main__":
    Commands.add(cmd)
    Commands.add(fnd)
    Commands.add(log)
    result = Result()
    result.txt = " ".join(sys.argv[1:])
    command(result)
    for line in result.result:
        print(line)
